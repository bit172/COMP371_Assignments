#version 330 core

// Input vertex data, different for all executions of this shader.
layout(location = 0) in vec3 vertexPosition_modelspace;
layout(location = 1) in vec3 vertexNormal_modelspace;  // You will need this when you do lighting
layout(location = 2) in vec3 vertexColor; 

// output to Fragment Shader
out vec3 v_color;

// Uniform
// Values that stay constant for the whole mesh.
uniform mat4 WorldTransform;
uniform mat4 ViewTransform;
uniform mat4 ProjectonTransform;


// Light and Material Uniform Variables
uniform vec4 WorldLightPosition; // if w = 1: Point light, if w = 0: directional light
uniform vec4 materialCoefficients; // x: ambient   y: diffuse   z: specular   w: specular exponent

uniform vec3 lightColor;
uniform vec3 lightAttenuation; // x: kC  y: kL  z: kQ

void main()
{
	mat4 MV = ViewTransform * WorldTransform;
	mat4 MVP = ProjectonTransform * MV;

	// Output position of the vertex, in clip space : MVP * position
	gl_Position =  MVP * vec4(vertexPosition_modelspace,1);
	v_color = vertexColor;

	// Implement Gouraud shading here...

	// Vertex Position in World Space
	vec3 vertexPosition_viewspace = vec3(MV * vec4(vertexPosition_modelspace,1.0f));
	// Light Position in viewspace
	vec3 ViewLightPosition = (ViewTransform * WorldLightPosition).xyz;
	// Light Vector (changes based on point/directional light)
	vec3 L = vec3(0.0f,0.0f,0.0f);
	// Normal in viewspace
	vec3 N = normalize(mat3(transpose(inverse(MV))) * vertexNormal_modelspace);
	// Ambient
	vec3 Ia = vec3(0.0f,0.0f,0.0f);
	// Diffuse
	vec3 Id = vec3(0.0f,0.0f,0.0f);	
	// Specular
	vec3 V = vec3(0.0f,0.0f,0.0f);
	vec3 R = vec3(0.0f,0.0f,0.0f);
	float spec = 0.0f;
	vec3 Is = vec3(0.0f,0.0f,0.0f);

	// Point
	if (WorldLightPosition.w == 1.0f)
	{
		L = normalize(ViewLightPosition - vertexPosition_viewspace);
		Ia = materialCoefficients.x * lightColor;
		float cosTheta = max(dot(N,L),0.0);
		float d = length(ViewLightPosition - vertexPosition_viewspace);
		float fAttenuation = 1.0/(lightAttenuation.x + lightAttenuation.y * d + lightAttenuation.z * (d * d));
		Id = fAttenuation * materialCoefficients.y * cosTheta * lightColor;
		V = normalize(transpose(ViewTransform)[3].xyz - vertexPosition_viewspace); 
		R = reflect(-L,N);
		spec = pow(max(dot(V,R), 0.0), materialCoefficients.w);
		Is = fAttenuation * materialCoefficients.z * spec * lightColor;
		v_color = ((Ia + Id) * vertexColor) + Is;
	}
	
	// Directional
	else if (WorldLightPosition.w == 0.0f)
	{
		L = normalize(ViewLightPosition);
		Ia = materialCoefficients.x * lightColor;
		float cosTheta = max(dot(N,L), 0.0);
		Id = materialCoefficients.y * cosTheta * lightColor;
		V = normalize(transpose(ViewTransform)[3].xyz - vertexPosition_viewspace); 
		R = reflect(-L,N);
		spec = pow(max(dot(V,R), 0.0), materialCoefficients.w);
		Is = materialCoefficients.z * spec * lightColor;
		v_color = ((Ia + Id) * vertexColor) + Is;
	}
	// ...


	// This should be the final color on the Vertex, including the lighting
	
}
